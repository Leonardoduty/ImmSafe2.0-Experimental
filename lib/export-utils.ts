// Export utilities for PDF, PNG, and ZIP downloads

export async function generateSurvivalPDF(data: {
  routeSummary: string
  supplies: string[]
  weatherWarnings: string[]
  hazardZones: string[]
  waterPoints: string[]
  emergencyContacts: string[]
}): Promise<Blob> {
  // Simple text-based PDF generation
  const lines: string[] = [
    "SURVIVAL PACK EXPORT",
    "=".repeat(50),
    "",
    "ROUTE SUMMARY:",
    data.routeSummary,
    "",
    "SUPPLIES:",
    ...data.supplies.map((s) => `- ${s}`),
    "",
    "WEATHER WARNINGS:",
    ...data.weatherWarnings.map((w) => `- ${w}`),
    "",
    "HAZARD ZONES:",
    ...data.hazardZones.map((h) => `- ${h}`),
    "",
    "CLEAN WATER POINTS:",
    ...data.waterPoints.map((p) => `- ${p}`),
    "",
    "EMERGENCY CONTACTS:",
    ...data.emergencyContacts.map((c) => `- ${c}`),
    "",
    "Generated by SafeRoute",
  ]

  const textContent = lines.join("\n")

  // Create simple PDF with text
  const pdfContent = createSimplePDF(textContent)
  return new Blob([pdfContent], { type: "application/pdf" })
}

function createSimplePDF(text: string): string {
  const lines = text.split("\n")
  let yPosition = 750
  let content = ""

  lines.forEach((line) => {
    content += `BT /F1 12 Tf 50 ${yPosition} Td (${escapePDFText(line)}) Tj ET\n`
    yPosition -= 15
  })

  const stream = `BT
/F1 12 Tf
50 750 Td
${lines.map((line, i) => `(${escapePDFText(line)}) Tj T* `).join("")}
ET`

  return (
    `%PDF-1.4
1 0 obj
<< /Type /Catalog /Pages 2 0 R >>
endobj
2 0 obj
<< /Type /Pages /Kids [3 0 R] /Count 1 >>
endobj
3 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 4 0 R /Resources << /Font << /F1 5 0 R >> >> >>
endobj
4 0 obj
<< /Length ${stream.length} >>
stream
${stream}
endstream
endobj
5 0 obj
<< /Type /Font /Subtype /Type1 /BaseFont /Helvetica >>
endobj
xref
0 6
0000000000 65535 f
0000000009 00000 n
0000000058 00000 n
0000000115 00000 n
0000000214 00000 n
0000000${(214 + stream.length + 50).toString().padStart(6, "0")} 00000 n
trailer
<< /Size 6 /Root 1 0 R >>
startxref
${214 + stream.length + 100}
%%EOF` + "\n"
  )
}

function escapePDFText(text: string): string {
  return text.replace(/\\/g, "\\\\").replace(/$$/g, "\\(").replace(/$$/g, "\\)")
}

export function exportMapAsPNG(canvas: HTMLCanvasElement): Blob {
  return new Promise((resolve) => {
    canvas.toBlob((blob) => {
      resolve(blob || new Blob())
    }, "image/png")
  })
}

export async function createOfflineZip(
  routeJSON: any,
  suppliesJSON: any,
  pdfBlob: Blob,
  pngBlob: Blob,
  translationsJSON: any,
): Promise<Blob> {
  const files: { name: string; content: string | Blob }[] = [
    { name: "route.json", content: JSON.stringify(routeJSON, null, 2) },
    { name: "supplies.json", content: JSON.stringify(suppliesJSON, null, 2) },
    { name: "translations.json", content: JSON.stringify(translationsJSON, null, 2) },
    { name: "map-snapshot.png", content: pngBlob },
    { name: "survival-guide.pdf", content: pdfBlob },
  ]

  // Simple ZIP creation using blob concatenation
  const zipBlob = new Blob(
    files.map((f) => f.content),
    { type: "application/zip" },
  )
  return zipBlob
}

export function downloadBlob(blob: Blob, filename: string) {
  const url = URL.createObjectURL(blob)
  const a = document.createElement("a")
  a.href = url
  a.download = filename
  document.body.appendChild(a)
  a.click()
  document.body.removeChild(a)
  URL.revokeObjectURL(url)
}
